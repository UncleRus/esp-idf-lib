---
name: Build examples
on:
  pull_request:
    types:
      - labeled
      - synchronize

jobs:
  pre_build:

    # A job to see if the entrire jobs should be skipped. each job for a
    # target should have:
    #
    # needs: pre_build
    # if: ${{ needs.pre_build.outputs.should_skip != 'true' }}
    #
    # Another output, component_labels, includes all the component labels of
    # the PR, e.g. "area:components:foo,area:components:bar".
    runs-on: ubuntu-latest
    outputs:
      should_skip: ${{ steps.skip_check.outputs.result }}
      component_labels: ${{ steps.get_component_labels.outputs.result }}
      components_to_build: ${{ steps.select_components_to_build.outputs.components_to_build }}
    steps:
      - id: skip_check
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            console.log("context");
            console.log(JSON.stringify(context, null, 2));
            let should_skip = false;

            switch(context.payload.action) {
              case "labeled":
                console.log("context.payload.label.name");
                console.log(JSON.stringify(context.payload.label.name));
                console.log("skip if the added label is not area:components nor area:components:*");
                  // "
                if (context.payload.label.name != "area:components" && !context.payload.label.name.startsWith("area:components:")) {
                  // "
                  should_skip = true;
                }

                console.log("but if it is area:ci label, don't skip because changes to the CI affect everything.");
                if (context.payload.label.name == "area:ci") {
                  should_skip = false;
                }
                break;
              case "synchronize":
                let labels = context.payload.pull_request.labels.map(label => { return label.name });
                console.log("labels");
                console.log(JSON.stringify(labels));

                console.log("skip if labels does not include area:components");
                if (!labels.includes("area:components")) {
                  console.log("area:components found in the labels");
                  should_skip = true;
                }

                console.log("but if labels include area:components:, do not skip");
                for (let i = 0; i < labels.length; i++) {
                  if (labels[i].startsWith("area:components:")) { // "
                    console.log("they does, do not skip");
                    should_skip = false;
                  }
                }

                console.log("but if labels include area:ci label, don't skip because changes to the CI affect everything.");
                if (labels.includes("area:ci")) {
                  console.log("they does, do not skip");
                  should_skip = false;
                }
                break;
              }
            return should_skip;

      - name: See if the PR has area:ci label
        id: has_area_ci_label
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            let result = false;
            try {
              pr = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.number,
              });
              console.log("pr");
              console.log(JSON.stringify(pr, null, 2));
              for (i = 0; i < pr.data.labels.length; i++) {
                if (pr.data.labels[i].name == "area:ci") {
                  result = true;
                }
              }

            } catch(e) {
                core.error(e);
                core.setFailed(e.message);
            }
            return result;

      - name: Get all area:components:* lables
        # this step returns a list of labels that start with "area:components:".
        # the output includes comma-separated list of labels, such as "area:
        # components:foo,area:components:bar".
        id: get_component_labels
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            console.log("context");
            console.log(JSON.stringify(context, null, 2));
            let i = 0;
            let component_labels = [];

            switch(context.payload.action) {
              case "labeled":
                try {
                  pr = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.payload.number,
                  });
                  console.log("pr");
                  console.log(JSON.stringify(pr, null, 2));

                  for (i = 0; i < pr.data.labels.length; i++) {
                    if (pr.data.labels[i].name.startsWith("area:components:")) {
                      // " vim syntax cannot parse above line, breaking syntax highlight
                      component_labels.push(pr.data.labels[i].name);
                    }
                  }
                } catch(e) {
                  core.error(e);
                  core.setFailed(e.message);
                }
                break;
                // append all labels that start with "area:components:"
              case "synchronize":
                let labels = context.payload.pull_request.labels.map(label => { return label.name });
                for (i = 0; i < labels.length; i++) {
                  if (labels[i].startsWith("area:components:")) {
                    // "
                    component_labels.push(labels[i]);
                  }
                }
                break;
              }
            return component_labels;

      - name: Checkout
        uses: actions/checkout@v3

      - name: Select components to build
        # this step returns a list of components to build
        id: select_components_to_build
        if: ${{ steps.skip_check.outputs.should_skip != 'true' }}
        run: |
          component_labels=`echo ${{ steps.get_component_labels.outputs.result }} | sed -e 's/,/ /g'`
          echo "The PR has the following component labels:"
          for component_label in ${component_labels}; do
            echo "${component_label}"
          done
          all_components=`ls -1 components`
          echo "The repository has the following components:"
          for component in ${all_components}; do
            echo "${component}"
          done
          components_to_build=""
          for component_label in ${component_labels}; do
            component_name=`echo ${component_label} | cut -f 3 -d':'`
            components_to_build="${components_to_build} ${component_name}"
            echo "components to build by labels"
            echo "${components_to_build}"
          done

          echo "Get a list of components by REQUIRES"
          extra_components_to_build_by_require=""

          # scan all component directories and if a component requires
          # one of components_to_build, add it to extra_components_to_build_by_require
          for component in ${components_to_build}; do
            for c in ${all_components}; do
              # the output is:
              # REQUIRES:log;color
              required=`cmake -DCOMPONENT_NAME:STRING=${c} devtools/cmake-get-requires  2>&1 >/dev/null | grep 'REQUIRES:' | cut -f2 -d':' | sed -e 's/;/ /g'`
              echo "component ${c} requires ${required}"
              for r in ${required}; do
                if echo "${all_components}" | grep -q "${r}"; then
                  echo "component ${r} is in all_components"
                  if [ "${r}" = "${component}" ]; then
                    echo "component ${c} requires ${component}, adding to extra_components_to_build_by_require"
                    extra_components_to_build_by_require="${extra_components_to_build_by_require} ${c}"
                  else
                    echo "component ${c} does not require ${component}, ignoring"
                  fi
                else
                  echo "component ${r} is not in all_components, ignoring"
                fi
              done
            done
          done
          # remove duplicated name from extra_components_to_build_by_require
          extra_components_to_build_by_require=`echo "${extra_components_to_build_by_require}" | tr ' ' '\n' | sort -u | tr '\n' ' '`

          echo "The list of components to build by REQUIRES:"
          echo "${extra_components_to_build_by_require}"

          # and merge everything
          components_to_build="${components_to_build} ${extra_components_to_build_by_require}"
          echo "components to build:"
          echo "${components_to_build}"

          # if component_labels has "area:ci" build all components
          if [ ${{ steps.has_area_ci_label.outputs.result }} == "true" ]; then
            echo "the PR has area:ci label, going to build all components"
            components_to_build="${all_components}"
          fi
          echo "The components to build:"
          components_to_build=`echo ${components_to_build} | tr "\n" " "`
          echo ${components_to_build}
          echo "components_to_build=${components_to_build}" > ${GITHUB_OUTPUT}

  # XXX create multiple jobs for major versions
  #
  # for those who want to _refactor_ the jobs:
  #
  # in the previous CI implementation, all builds share a single build
  # process. that way, you can remove duplications. however, every time a
  # version changes the build process, the change affects all other build
  # processes. I am tired of tracking changes and workarounds in the build
  # process. the result is many `if`s. assuming major version does not change
  # (a lot) its build process, creating multiple jobs, and using matrix is the
  # only sane way. as GitHub Actions does not support reusable steps, there
  # are many duplications. but no need to modify the entire build process to
  # adopt changes in master.
  build_esp32_master:
    needs: pre_build
    if: ${{ needs.pre_build.outputs.should_skip != 'true' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        target:
          - esp32
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          sudo apt-get install \
            bison \
            ccache \
            flex \
            gcc \
            git \
            gperf \
            libffi-dev \
            libncurses-dev \
            libssl-dev \
            make \
            wget

      - name: Set environment variables
        id: set_env
        run: |
          REPO_DIR=`pwd`
          EXAMPLE_DIR="${REPO_DIR}/examples"
          __PROJECT_PATH=`pwd`

          # XXX actions/checkout does not allow to checkout a repository other
          # than under __PROJECT_PATH
          IDF_PATH="${__PROJECT_PATH}/idf"

          echo "IDF_PATH=${IDF_PATH}" >> ${GITHUB_ENV}
          echo "IDF_TARGET=${{ matrix.target }}" >> ${GITHUB_ENV}

          # XXX prefix all the environment variables with `__PROJECT_` to avoid pollution
          echo "__PROJECT_EXAMPLE_DIR=${EXAMPLE_DIR}" >> ${GITHUB_ENV}

      - name: Checkout the SDK
        uses: actions/checkout@v3
        with:
          repository: espressif/esp-idf
          path: idf
          submodules: recursive
          ref: master

      - name: Run idf_tools.py install
        run: |
          ${IDF_PATH}/tools/idf_tools.py install

      - name: Run idf_tools.py install-python-env
        run: |
          ${IDF_PATH}/tools/idf_tools.py install-python-env

      - name: Build (idf.py)
        run: |
          components_to_build="${{ needs.pre_build.outputs.components_to_build }}"

          echo "The component whose examples need to be built:"
          echo "${components_to_build}"

          # find out drivers that do not support the target
          EXCLUDE_COMPONENTS=""
          ALL_COMPONENTS=`ls -1 components`
          for C in ${ALL_COMPONENTS}; do
            echo "see if component ${C} supports the target ${IDF_TARGET}"
            if [ ! -f "components/${C}/.eil.yml" ]; then
              echo "metadata file for component ${C}, components/${C}/.eil.yml, does not exist"
              exit 1
            fi
            if yq '.components[].targets[].name' "components/${C}/.eil.yml" | grep -q ${IDF_TARGET}; then
              echo "component ${C} supports ${IDF_TARGET}"
            else
              echo "component ${C} does not support ${IDF_TARGET}. adding it to EXCLUDE_COMPONENTS"
              EXCLUDE_COMPONENTS="${EXCLUDE_COMPONENTS} ${C}"
            fi
          done
          echo "EXCLUDE_COMPONENTS=${EXCLUDE_COMPONENTS}"
          export EXCLUDE_COMPONENTS

          # remove components in EXCLUDE_COMPONENTS from components_to_build
          for ec in ${EXCLUDE_COMPONENTS}; do
            components_to_build=`echo ${components_to_build} | tr ' ' '\n' | grep -v ${ec} | tr '\n' ' '`
          done

          . ${IDF_PATH}/export.sh

          # XXX share cache between examples.
          # see "Compiling In Different Directories" in ccache(1)
          # |                                        |  4.0.1  | master  |
          # |----------------------------------------|---------|---------|
          # | without ccache                         | 33m 42s | 50m 27s |
          # | CCACHE_BASEDIR and CCACHE_NOHASHDIR    | 10m 41s | 16m 38s |
          export CCACHE_BASEDIR="${__PROJECT_EXAMPLE_DIR}"
          export CCACHE_NOHASHDIR=true

          echo "final components_to_build:"
          echo "${components_to_build}"
          for component_to_build in ${components_to_build}; do
            cd ${GITHUB_WORKSPACE}
            echo "Building examples for ${component_to_build} under directory ${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            for i in $(ls -d *); do
              cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}/${i}"
              echo "Building example ${i} for component ${component_to_build} in directory ${PWD}..."
              idf.py --ccache build
            done
          done

  build_esp32_v4_x:
    needs: pre_build
    if: ${{ needs.pre_build.outputs.should_skip != 'true' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        build_method:
          - idf
          - make
        branch:

          # for supported versions by espressif, see:
          # https://docs.espressif.com/projects/esp-idf/en/latest/esp32/versions.html
          - v4.1.3
          - v4.2.3
          - v4.3.4
          - v4.4.2
        target:
          - esp32
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          sudo apt-get install \
            bison \
            ccache \
            flex \
            gcc \
            git \
            gperf \
            libffi-dev \
            libncurses-dev \
            libssl-dev \
            make \
            wget

      - name: Set environment variables
        id: set_env
        run: |
          SDK_NAME="esp-idf"
          GCC_PREFIX="xtensa-${{ matrix.target }}-elf"
          GCC_FILE="${GCC_PREFIX}-gcc"
          TOOLCHAIN_DIR="${HOME}/.espressif/tools"
          case "${{ matrix.branch }}" in
          v4.0.*)
            TOOLCHAIN_VERSION="esp-2020r3-8.4.0"
            ;;
          v4.1.*)
            TOOLCHAIN_VERSION="esp-2020r3-8.4.0"
            ;;
          v4.2.*)
            TOOLCHAIN_VERSION="esp-2020r3-8.4.0"
            ;;
          v4.3.*)
            TOOLCHAIN_VERSION="esp-2021r2-patch3-8.4.0"
            ;;
          v4.4.*)
            TOOLCHAIN_VERSION="esp-2021r2-patch3-8.4.0"
            ;;
          *)
            echo "Unknown matrix.branch: ${{ matrix.branch }}"
            exit 1
            ;;
          esac
          REPO_DIR=`pwd`
          EXAMPLE_DIR="${REPO_DIR}/examples"
          DISTFILE_DIR="${HOME}/distfiles"
          __PROJECT_PATH=`pwd`

          # XXX actions/checkout does not allow to checkout a repository other
          # than under __PROJECT_PATH
          IDF_PATH="${__PROJECT_PATH}/idf"

          echo "IDF_PATH=${IDF_PATH}" >> ${GITHUB_ENV}
          echo "IDF_TARGET=${{ matrix.target }}" >> ${GITHUB_ENV}

          # cache-idf-tools needs __PROJECT_TOOLCHAIN_DIR
          echo "PROJECT_TOOLCHAIN_DIR=${TOOLCHAIN_DIR}" >> $GITHUB_OUTPUT

          # XXX prefix all the environment variables with `__PROJECT_` to avoid pollution
          echo "__PROJECT_EXAMPLE_DIR=${EXAMPLE_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_GCC_FILE=${GCC_FILE}" >> ${GITHUB_ENV}
          echo "__PROJECT_GCC_PREFIX=${GCC_PREFIX}" >> ${GITHUB_ENV}
          echo "__PROJECT_SDK_NAME=${SDK_NAME}" >> ${GITHUB_ENV}
          echo "__PROJECT_TOOLCHAIN_FILE=${TOOLCHAIN_FILE}" >> ${GITHUB_ENV}
          echo "__PROJECT_TOOLCHAIN_DIR=${TOOLCHAIN_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_TOOLCHAIN_VERSION=${TOOLCHAIN_VERSION}" >> ${GITHUB_ENV}
          echo "__PROJECT_DISTFILE_DIR=${DISTFILE_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_PATH=${__PROJECT_PATH}" >> ${GITHUB_ENV}
          echo "__PROJECT_BUILD_COMMAND=${__PROJECT_BUILD_COMMAND}" >> ${GITHUB_ENV}
          echo "__PROJECT_BUILD_COMMAND_ARG=${__PROJECT_BUILD_COMMAND_ARG}" >> ${GITHUB_ENV}

      - name: Checkout the SDK
        uses: actions/checkout@v3
        with:
          repository: espressif/esp-idf
          path: idf
          submodules: recursive
          ref: ${{ matrix.branch }}

      - name: Cache esp-idf tools

        # cache esp-idf tools. each tagged branch has fixed versions of tools.
        # the versions do not change. the master is an exception as it is a
        # moving target. do NOT cache tools if the branch is master.
        uses: actions/cache@v3
        id: cache-tools
        with:
          path: ${{ steps.set_env.outputs.PROJECT_TOOLCHAIN_DIR }}
          key: ${{ runner.os }}-${{ matrix.branch }}-${{ matrix.target }}-cache-tools

      - name: Run idf_tools.py install
        if: ${{ steps.cache-tools.outputs.cache-hit != 'true' }}
        run: |
          ${IDF_PATH}/tools/idf_tools.py install

      - name: Run idf_tools.py install-python-env
        run: |
          ${IDF_PATH}/tools/idf_tools.py install-python-env

      - name: Build (idf.py)
        if: ${{ matrix.build_method == 'idf' }}
        run: |
          components_to_build="${{ needs.pre_build.outputs.components_to_build }}"

          echo "The component whose examples need to be built:"
          echo "${components_to_build}"

          # find out drivers that do not support the target
          EXCLUDE_COMPONENTS=""
          ALL_COMPONENTS=`ls -1 components`
          for C in ${ALL_COMPONENTS}; do
            echo "see if component ${C} supports the target ${IDF_TARGET}"
            if [ ! -f "components/${C}/.eil.yml" ]; then
              echo "metadata file for component ${C}, components/${C}/.eil.yml, does not exist"
              exit 1
            fi
            if yq '.components[].targets[].name' "components/${C}/.eil.yml" | grep -q ${IDF_TARGET}; then
              echo "component ${C} supports ${IDF_TARGET}"
            else
              echo "component ${C} does not support ${IDF_TARGET}. adding it to EXCLUDE_COMPONENTS"
              EXCLUDE_COMPONENTS="${EXCLUDE_COMPONENTS} ${C}"
            fi
          done
          echo "EXCLUDE_COMPONENTS=${EXCLUDE_COMPONENTS}"
          export EXCLUDE_COMPONENTS

          # remove components in EXCLUDE_COMPONENTS from components_to_build
          for ec in ${EXCLUDE_COMPONENTS}; do
            components_to_build=`echo ${components_to_build} | tr ' ' '\n' | grep -v ${ec} | tr '\n' ' '`
          done

          . ${IDF_PATH}/export.sh

          # XXX share cache between examples.
          # see "Compiling In Different Directories" in ccache(1)
          # |                                        |  4.0.1  | master  |
          # |----------------------------------------|---------|---------|
          # | without ccache                         | 33m 42s | 50m 27s |
          # | CCACHE_BASEDIR and CCACHE_NOHASHDIR    | 10m 41s | 16m 38s |
          export CCACHE_BASEDIR="${__PROJECT_EXAMPLE_DIR}"
          export CCACHE_NOHASHDIR=true

          echo "final components_to_build:"
          echo "${components_to_build}"
          for component_to_build in ${components_to_build}; do
            cd ${GITHUB_WORKSPACE}
            echo "Building examples for ${component_to_build} under directory ${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            for i in $(ls -d *); do
              cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}/${i}"
              echo "Building example ${i} for component ${component_to_build} in directory ${PWD}..."
              idf.py --ccache build
            done
          done

      - name: Setup ccache (make)

        # XXX ccache needs to be configured here
        # unlike idf.py, esp-idf does nothing to setup ccache for make.
        # IDF_CCACHE_ENABLE does not work either.
        if: ${{ matrix.build_method == 'make' }}
        run: |
          GCC_BIN_DIR="${__PROJECT_TOOLCHAIN_DIR}/${__PROJECT_GCC_PREFIX}/${__PROJECT_TOOLCHAIN_VERSION}/${__PROJECT_GCC_PREFIX}/bin"
          CCACHE_BIN_DIR="${HOME}/ccache_bin"
          mkdir -p "${CCACHE_BIN_DIR}"
          (cd "${CCACHE_BIN_DIR}" && ln -s /usr/bin/ccache "${__PROJECT_GCC_FILE}")
          export PATH="${CCACHE_BIN_DIR}:$PATH:${GCC_BIN_DIR}"
          echo "PATH=${PATH}" >> ${GITHUB_ENV}
          echo "CCACHE_BASEDIR=${__PROJECT_EXAMPLE_DIR}" >> ${GITHUB_ENV}
          echo "CCACHE_NOHASHDIR=true" >> ${GITHUB_ENV}

      - name: Build (make)
        if: ${{ matrix.build_method == 'make' }}
        run: |
          components_to_build="${{ needs.pre_build.outputs.components_to_build }}"

          echo "The component whose examples need to be built:"
          echo "${components_to_build}"

          # make sure gcc is in $PATH
          echo ${PATH}
          ${__PROJECT_GCC_FILE} --version

          # find out drivers that do not support the target
          EXCLUDE_COMPONENTS=""
          ALL_COMPONENTS=`ls -1 components`
          for C in ${ALL_COMPONENTS}; do
            echo "see if component ${C} supports the target ${IDF_TARGET}"
            if [ ! -f "components/${C}/.eil.yml" ]; then
              echo "metadata file for component ${C}, components/${C}/.eil.yml, does not exist"
              exit 1
            fi
            if yq '.components[].targets[].name' "components/${C}/.eil.yml" | grep -q ${IDF_TARGET}; then
              echo "component ${C} supports ${IDF_TARGET}"
            else
              echo "component ${C} does not support ${IDF_TARGET}. adding it to EXCLUDE_COMPONENTS"
              EXCLUDE_COMPONENTS="${EXCLUDE_COMPONENTS} ${C}"
            fi
          done
          echo "EXCLUDE_COMPONENTS=${EXCLUDE_COMPONENTS}"
          export EXCLUDE_COMPONENTS

          # remove components in EXCLUDE_COMPONENTS from components_to_build
          for ec in ${EXCLUDE_COMPONENTS}; do
            components_to_build=`echo ${components_to_build} | tr ' ' '\n' | grep -v ${ec} | tr '\n' ' '`
          done

          . ${IDF_PATH}/export.sh

          # XXX share cache between examples.
          # see "Compiling In Different Directories" in ccache(1)
          # |                                        |  4.0.1  | master  |
          # |----------------------------------------|---------|---------|
          # | without ccache                         | 33m 42s | 50m 27s |
          # | CCACHE_BASEDIR and CCACHE_NOHASHDIR    | 10m 41s | 16m 38s |
          export CCACHE_BASEDIR="${__PROJECT_EXAMPLE_DIR}"
          export CCACHE_NOHASHDIR=true

          echo "final components_to_build:"
          echo "${components_to_build}"
          for component_to_build in ${components_to_build}; do
            cd ${GITHUB_WORKSPACE}
            echo "Building examples for ${component_to_build} under directory ${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            for i in $(ls -d *); do
              cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}/${i}"
              echo "Building example ${i} for component ${component_to_build} in directory ${PWD}..."
              make defconfig
              make -j$(nproc)
            done
          done

  build_esp8266:
    runs-on: ubuntu-latest
    needs: pre_build
    if: ${{ needs.pre_build.outputs.should_skip != 'true' }}
    strategy:
      fail-fast: false
      matrix:
        build_method:

          # XXX build examples with make only
          # idf.py in ESP8266 RTOS SDK is broken in many ways.
          - make
        branch:
          - v3.4
          - master
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          sudo apt-get install \
            bison \
            ccache \
            flex \
            gcc \
            git \
            gperf \
            libffi-dev \
            libncurses-dev \
            libssl-dev \
            make \
            wget

      - name: Install yq to parse YAML files
        run: |
          YQ_VERSION=v4.25.3
          YQ_BINARY=yq_linux_amd64
          YQ_COMMAND="/usr/bin/yq"
          wget "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${YQ_BINARY}" -O ./yq
          sudo mv ./yq "${YQ_COMMAND}"
          sudo chmod +x "${YQ_COMMAND}"
          "${YQ_COMMAND}" --version

      - name: Set environment variables
        id: set_env
        run: |
          SDK_NAME="ESP8266_RTOS_SDK"
          GCC_PREFIX="xtensa-lx106-elf"
          GCC_FILE="${GCC_PREFIX}-gcc"
          TOOLCHAIN_DIR="${HOME}/.espressif/tools"
          REPO_DIR=`pwd`
          EXAMPLE_DIR="${REPO_DIR}/examples"
          __PROJECT_PATH=`pwd`
          __PROJECT_TOOLCHAIN_VERSION="esp-2020r3-49-gd5524c1-8.4.0"

          # XXX actions/checkout does not allow to checkout a repository other
          # than under __PROJECT_PATH
          IDF_PATH="${__PROJECT_PATH}/idf"

          echo "IDF_PATH=${IDF_PATH}" >> ${GITHUB_ENV}
          echo "IDF_TARGET=esp8266" >> ${GITHUB_ENV}

          # cache-idf-tools needs PROJECT_TOOLCHAIN_DIR
          echo "PROJECT_TOOLCHAIN_DIR=${TOOLCHAIN_DIR}" >> $GITHUB_OUTPUT

          # XXX prefix all the environment variables with `__PROJECT_` to avoid pollution
          echo "__PROJECT_EXAMPLE_DIR=${EXAMPLE_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_GCC_FILE=${GCC_FILE}" >> ${GITHUB_ENV}
          echo "__PROJECT_GCC_PREFIX=${GCC_PREFIX}" >> ${GITHUB_ENV}
          echo "__PROJECT_TOOLCHAIN_DIR=${TOOLCHAIN_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_PATH=${__PROJECT_PATH}" >> ${GITHUB_ENV}
          echo "__PROJECT_BUILD_COMMAND=${__PROJECT_BUILD_COMMAND}" >> ${GITHUB_ENV}
          echo "__PROJECT_BUILD_COMMAND_ARG=${__PROJECT_BUILD_COMMAND_ARG}" >> ${GITHUB_ENV}
          echo "__PROJECT_TOOLCHAIN_VERSION=${__PROJECT_TOOLCHAIN_VERSION}" >> ${GITHUB_ENV}

      - name: Checkout the SDK
        uses: actions/checkout@v3
        with:
          repository: espressif/ESP8266_RTOS_SDK
          path: idf
          submodules: recursive
          ref: ${{ matrix.branch }}
          # XXX git.eclipse.org does not allow to fetch a commit. fetch all
          # the commits.
          fetch-depth: 0

      - name: Install python requirements (pip)
        run: |
          python -m pip install --user -r ${IDF_PATH}/requirements.txt

      - name: Cache toolchain
        id: cache-idf-tools
        if: ${{ matrix.branch != 'master' }}
        uses: actions/cache@v3
        with:
          path: ${{ steps.set_env.outputs.PROJECT_TOOLCHAIN_DIR }}
          key: ${{ runner.os }}-${{ matrix.branch }}-esp8266-cache-tools

      - name: Install toolchain
        if: ${{ steps.cache-idf-tools.outputs.cache-hit != 'true' || matrix.branch == 'master' }}
        run: |
          ${IDF_PATH}/install.sh

      - name: Setup ccache (make)
        run: |
          __PROJECT_CCACHE_BIN_DIR="${HOME}/ccache_bin"
          mkdir -p "${__PROJECT_CCACHE_BIN_DIR}"
          (cd "${__PROJECT_CCACHE_BIN_DIR}" && ln -s /usr/bin/ccache "${__PROJECT_GCC_FILE}")
          echo "PATH=${__PROJECT_CCACHE_BIN_DIR}:$PATH:${__PROJECT_TOOLCHAIN_DIR}/${__PROJECT_GCC_PREFIX}/${__PROJECT_TOOLCHAIN_VERSION}/${__PROJECT_GCC_PREFIX}/bin" >> ${GITHUB_ENV}
          echo "CCACHE_BASEDIR=${__PROJECT_EXAMPLE_DIR}" >> ${GITHUB_ENV}
          echo "CCACHE_NOHASHDIR=true" >> ${GITHUB_ENV}

      - name: Build (make)
        if: ${{ matrix.build_method == 'make' }}
        run: |
          components_to_build="${{ needs.pre_build.outputs.components_to_build }}"

          echo "The component whose examples need to be built:"
          echo "${components_to_build}"

          # make sure gcc is in $PATH
          echo ${PATH}
          ${__PROJECT_GCC_FILE} --version

          # find out drivers that do not support the target
          EXCLUDE_COMPONENTS=""
          ALL_COMPONENTS=`ls -1 components`
          for C in ${ALL_COMPONENTS}; do
            echo "see if component ${C} supports the target ${IDF_TARGET}"
            if [ ! -f "components/${C}/.eil.yml" ]; then
              echo "metadata file for component ${C}, components/${C}/.eil.yml, does not exist"
              exit 1
            fi
            if yq '.components[].targets[].name' "components/${C}/.eil.yml" | grep -q ${IDF_TARGET}; then
              echo "component ${C} supports ${IDF_TARGET}"
            else
              echo "component ${C} does not support ${IDF_TARGET}. adding it to EXCLUDE_COMPONENTS"
              EXCLUDE_COMPONENTS="${EXCLUDE_COMPONENTS} ${C}"
            fi
          done
          echo "EXCLUDE_COMPONENTS=${EXCLUDE_COMPONENTS}"
          export EXCLUDE_COMPONENTS

          # remove components in EXCLUDE_COMPONENTS from components_to_build
          for ec in ${EXCLUDE_COMPONENTS}; do
            components_to_build=`echo ${components_to_build} | tr ' ' '\n' | grep -v ${ec} | tr '\n' ' '`
          done

          # XXX share cache between examples.
          # see "Compiling In Different Directories" in ccache(1)
          # |                                        |  4.0.1  | master  |
          # |----------------------------------------|---------|---------|
          # | without ccache                         | 33m 42s | 50m 27s |
          # | CCACHE_BASEDIR and CCACHE_NOHASHDIR    | 10m 41s | 16m 38s |
          export CCACHE_BASEDIR="${__PROJECT_EXAMPLE_DIR}"
          export CCACHE_NOHASHDIR=true

          echo "final components_to_build:"
          echo "${components_to_build}"
          for component_to_build in ${components_to_build}; do
            cd ${GITHUB_WORKSPACE}
            echo "Building examples for ${component_to_build} under directory ${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            for i in $(ls -d *); do
              cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}/${i}"
              echo "Building example ${i} for component ${component_to_build} in directory ${PWD}..."
              make defconfig
              make -j$(nproc)
            done
          done

  build_esp8266_v3_3_x:
    runs-on: ubuntu-latest
    needs: pre_build
    if: ${{ needs.pre_build.outputs.should_skip != 'true' }}
    strategy:
      fail-fast: false
      matrix:
        build_method:

          # XXX build examples with make only
          # idf.py in ESP8266 RTOS SDK is broken in many ways.
          - make
        branch:
          - v3.3
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          sudo apt-get install \
            bison \
            ccache \
            flex \
            gcc \
            git \
            gperf \
            libffi-dev \
            libncurses-dev \
            libssl-dev \
            make \
            wget

      - name: Set environment variables
        id: set_env
        run: |
          SDK_NAME="ESP8266_RTOS_SDK"
          GCC_PREFIX="xtensa-lx106-elf"
          GCC_FILE="${GCC_PREFIX}-gcc"
          TOOLCHAIN_DIR="${HOME}/esp32"
          case "${{ matrix.branch }}" in
          v3.3)
            TOOLCHAIN_FILE="xtensa-lx106-elf-linux64-1.22.0-100-ge567ec7-5.2.0.tar.gz"
            ;;
          v3.4)
            TOOLCHAIN_FILE="xtensa-lx106-elf-gcc8_4_0-esp-2020r3-linux-amd64.tar.gz"
            ;;
          *)
            echo "unknown matrix.branch ${{ matrix.branch }}"
            exit 1
            ;;
          esac
          REPO_DIR=`pwd`
          EXAMPLE_DIR="${REPO_DIR}/examples"
          DISTFILE_DIR="${HOME}/distfiles"
          __PROJECT_PATH=`pwd`

          # XXX actions/checkout does not allow to checkout a repository other
          # than under __PROJECT_PATH
          IDF_PATH="${__PROJECT_PATH}/idf"

          echo "IDF_PATH=${IDF_PATH}" >> ${GITHUB_ENV}
          echo "IDF_TARGET=esp8266" >> ${GITHUB_ENV}

          # cache-idf-tools needs PROJECT_DISTFILE_DIR
          echo "PROJECT_DISTFILE_DIR=${DISTFILE_DIR}" >> ${GITHUB_OUTPUT}

          # XXX prefix all the environment variables with `__PROJECT_` to avoid pollution
          echo "__PROJECT_EXAMPLE_DIR=${EXAMPLE_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_GCC_FILE=${GCC_FILE}" >> ${GITHUB_ENV}
          echo "__PROJECT_GCC_PREFIX=${GCC_PREFIX}" >> ${GITHUB_ENV}
          echo "__PROJECT_SDK_NAME=${SDK_NAME}" >> ${GITHUB_ENV}
          echo "__PROJECT_TOOLCHAIN_DIR=${TOOLCHAIN_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_TOOLCHAIN_FILE=${TOOLCHAIN_FILE}" >> ${GITHUB_ENV}
          echo "__PROJECT_DISTFILE_DIR=${DISTFILE_DIR}" >> ${GITHUB_ENV}
          echo "__PROJECT_PATH=${__PROJECT_PATH}" >> ${GITHUB_ENV}
          echo "__PROJECT_BUILD_COMMAND=${__PROJECT_BUILD_COMMAND}" >> ${GITHUB_ENV}
          echo "__PROJECT_BUILD_COMMAND_ARG=${__PROJECT_BUILD_COMMAND_ARG}" >> ${GITHUB_ENV}

      - name: Checkout the SDK
        uses: actions/checkout@v3
        with:
          repository: espressif/ESP8266_RTOS_SDK
          path: idf
          submodules: recursive
          ref: ${{ matrix.branch }}
          # XXX git.eclipse.org does not allow to fetch a commit. fetch all
          # the commits.
          fetch-depth: 0

      - name: Install python requirements (pip)
        run: |

          # XXX upgrade pyOpenSSL because older pyOpenSSL caused issues in
          # the past. this might not be true anymore.
          python -m pip install --user --upgrade pyOpenSSL
          python -m pip install --user -r ${IDF_PATH}/requirements.txt

      - name: Create __PROJECT_DISTFILE_DIR
        run: |
          mkdir -p "${__PROJECT_DISTFILE_DIR}"

      - name: Cache toolchain
        id: cache-idf-tools
        uses: actions/cache@v3
        with:
          path: ${{ steps.set_env.outputs.PROJECT_DISTFILE_DIR }}
          key: ${{ runner.os }}-${{ matrix.branch }}-esp8266-cache-tools

      - name: Download toolchain if it does not exist
        run: |
          if [ ! -f "${__PROJECT_DISTFILE_DIR}/${__PROJECT_TOOLCHAIN_FILE}" ]; then
            wget -O "${__PROJECT_DISTFILE_DIR}/${__PROJECT_TOOLCHAIN_FILE}" "https://dl.espressif.com/dl/${__PROJECT_TOOLCHAIN_FILE}"
          fi

      - name: Extract the toolchain
        run: |
          mkdir -p "${__PROJECT_TOOLCHAIN_DIR}"
          tar -xz -C "${__PROJECT_TOOLCHAIN_DIR}" -f "${__PROJECT_DISTFILE_DIR}/${__PROJECT_TOOLCHAIN_FILE}"

      - name: Setup ccache
        run: |
          __PROJECT_CCACHE_BIN_DIR="${HOME}/ccache_bin"
          mkdir -p "${__PROJECT_CCACHE_BIN_DIR}"
          (cd "${__PROJECT_CCACHE_BIN_DIR}" && ln -s /usr/bin/ccache "${__PROJECT_GCC_FILE}")
          echo "PATH=${__PROJECT_CCACHE_BIN_DIR}:$PATH:${__PROJECT_TOOLCHAIN_DIR}/${__PROJECT_GCC_PREFIX}/bin" >> ${GITHUB_ENV}
          echo "CCACHE_BASEDIR=${__PROJECT_EXAMPLE_DIR}" >> ${GITHUB_ENV}
          echo "CCACHE_NOHASHDIR=true" >> ${GITHUB_ENV}

      - name: Build (make)
        if: ${{ matrix.build_method == 'make' }}
        run: |
          components_to_build="${{ needs.pre_build.outputs.components_to_build }}"

          echo "The component whose examples need to be built:"
          echo "${components_to_build}"

          # make sure gcc is in $PATH
          echo ${PATH}
          ${__PROJECT_GCC_FILE} --version

          # find out drivers that do not support the target
          EXCLUDE_COMPONENTS=""
          ALL_COMPONENTS=`ls -1 components`
          for C in ${ALL_COMPONENTS}; do
            echo "see if component ${C} supports the target ${IDF_TARGET}"
            if [ ! -f "components/${C}/.eil.yml" ]; then
              echo "metadata file for component ${C}, components/${C}/.eil.yml, does not exist"
              exit 1
            fi
            if yq '.components[].targets[].name' "components/${C}/.eil.yml" | grep -q ${IDF_TARGET}; then
              echo "component ${C} supports ${IDF_TARGET}"
            else
              echo "component ${C} does not support ${IDF_TARGET}. adding it to EXCLUDE_COMPONENTS"
              EXCLUDE_COMPONENTS="${EXCLUDE_COMPONENTS} ${C}"
            fi
          done
          echo "EXCLUDE_COMPONENTS=${EXCLUDE_COMPONENTS}"
          export EXCLUDE_COMPONENTS

          # remove components in EXCLUDE_COMPONENTS from components_to_build
          for ec in ${EXCLUDE_COMPONENTS}; do
            components_to_build=`echo ${components_to_build} | tr ' ' '\n' | grep -v ${ec} | tr '\n' ' '`
          done

          # XXX share cache between examples.
          # see "Compiling In Different Directories" in ccache(1)
          # |                                        |  4.0.1  | master  |
          # |----------------------------------------|---------|---------|
          # | without ccache                         | 33m 42s | 50m 27s |
          # | CCACHE_BASEDIR and CCACHE_NOHASHDIR    | 10m 41s | 16m 38s |
          export CCACHE_BASEDIR="${__PROJECT_EXAMPLE_DIR}"
          export CCACHE_NOHASHDIR=true

          echo "final components_to_build:"
          echo "${components_to_build}"
          for component_to_build in ${components_to_build}; do
            cd ${GITHUB_WORKSPACE}
            echo "Building examples for ${component_to_build} under directory ${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            for i in $(ls -d *); do
              cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}/${i}"
              echo "Building example ${i} for component ${component_to_build} in directory ${PWD}..."
              make defconfig
              make -j$(nproc)
            done
          done

  # XXX esp32s2 support was introduced in v4.2. older esp-idf does not install
  # toolchains for esp32s2. thus, you cannot add `esp32s2` target to
  # build_esp32_v4_x.
  #
  # this job can be removed when either one of the followings are met:
  #
  # * GitHub Actions supports "early exit" (successfully exit if a condition is
  #   true).
  # * all branches in build_esp32_v4_x supports esp32s2
  #
  # additionally, esp32s2 build requires idf.py. make is not supported.
  build_esp32s2_v4_x:
    runs-on: ubuntu-latest
    needs: pre_build
    if: ${{ needs.pre_build.outputs.should_skip != 'true' }}
    strategy:
      fail-fast: false
      matrix:
        build_method:
          - idf
        branch:

          # esp32s2 support since v4.2.x
          - master
          - v4.2.3
          - v4.3.4
          - v4.4.2
        target:
          - esp32s2
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          sudo apt-get install \
            bison \
            ccache \
            flex \
            gcc \
            git \
            gperf \
            libffi-dev \
            libncurses-dev \
            libssl-dev \
            make \
            wget

      - name: Set environment variables
        id: set_env
        run: |
          TOOLCHAIN_DIR="${HOME}/.espressif/tools"
          REPO_DIR=`pwd`
          EXAMPLE_DIR="${REPO_DIR}/examples"
          __PROJECT_PATH=`pwd`
          IDF_PATH="${__PROJECT_PATH}/idf"

          # cache-idf-tools needs __PROJECT_TOOLCHAIN_DIR
          echo "PROJECT_TOOLCHAIN_DIR=${TOOLCHAIN_DIR}" >> $GITHUB_OUTPUT

          echo "IDF_PATH=${IDF_PATH}" >> ${GITHUB_ENV}
          echo "IDF_TARGET=${{ matrix.target }}" >> ${GITHUB_ENV}
          echo "__PROJECT_EXAMPLE_DIR=${EXAMPLE_DIR}" >> ${GITHUB_ENV}

      - name: Checkout the SDK
        uses: actions/checkout@v3
        with:
          repository: espressif/esp-idf
          path: idf
          submodules: recursive
          ref: ${{ matrix.branch }}

      - name: Cache esp-idf tools

        # cache esp-idf tools. each tagged branch has fixed versions of tools.
        # the versions do not change. the master is an exception as it is a
        # moving target. do NOT cache tools if the branch is master.
        uses: actions/cache@v3
        id: cache-tools
        if: ${{ matrix.branch != 'master' }}
        with:
          path: ${{ steps.set_env.outputs.PROJECT_TOOLCHAIN_DIR }}
          key: ${{ runner.os }}-${{ matrix.branch }}-${{ matrix.target }}-cache-tools

      - name: Run install.sh
        if: ${{ steps.cache-tools.outputs.cache-hit != 'true' || matrix.branch == 'master' }}
        run: |
          ${IDF_PATH}/install.sh

      - name: Run idf_tools.py install-python-env
        run: |
          ${IDF_PATH}/tools/idf_tools.py install-python-env

      - name: Build (idf.py)
        if: ${{ matrix.build_method == 'idf' }}
        run: |
          components_to_build="${{ needs.pre_build.outputs.components_to_build }}"

          echo "The component whose examples need to be built:"
          echo "${components_to_build}"

          # find out drivers that do not support the target
          EXCLUDE_COMPONENTS=""
          ALL_COMPONENTS=`ls -1 components`
          for C in ${ALL_COMPONENTS}; do
            echo "see if component ${C} supports the target ${IDF_TARGET}"
            if [ ! -f "components/${C}/.eil.yml" ]; then
              echo "metadata file for component ${C}, components/${C}/.eil.yml, does not exist"
              exit 1
            fi
            if yq '.components[].targets[].name' "components/${C}/.eil.yml" | grep -q ${IDF_TARGET}; then
              echo "component ${C} supports ${IDF_TARGET}"
            else
              echo "component ${C} does not support ${IDF_TARGET}. adding it to EXCLUDE_COMPONENTS"
              EXCLUDE_COMPONENTS="${EXCLUDE_COMPONENTS} ${C}"
            fi
          done
          echo "EXCLUDE_COMPONENTS=${EXCLUDE_COMPONENTS}"
          export EXCLUDE_COMPONENTS

          # remove components in EXCLUDE_COMPONENTS from components_to_build
          for ec in ${EXCLUDE_COMPONENTS}; do
            components_to_build=`echo ${components_to_build} | tr ' ' '\n' | grep -v ${ec} | tr '\n' ' '`
          done

          . ${IDF_PATH}/export.sh

          # XXX share cache between examples.
          # see "Compiling In Different Directories" in ccache(1)
          # |                                        |  4.0.1  | master  |
          # |----------------------------------------|---------|---------|
          # | without ccache                         | 33m 42s | 50m 27s |
          # | CCACHE_BASEDIR and CCACHE_NOHASHDIR    | 10m 41s | 16m 38s |
          export CCACHE_BASEDIR="${__PROJECT_EXAMPLE_DIR}"
          export CCACHE_NOHASHDIR=true

          echo "final components_to_build:"
          echo "${components_to_build}"
          for component_to_build in ${components_to_build}; do
            cd ${GITHUB_WORKSPACE}
            echo "Building examples for ${component_to_build} under directory ${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            for i in $(ls -d *); do
              cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}/${i}"
              echo "Building example ${i} for component ${component_to_build} in directory ${PWD}..."
              idf.py --ccache build
            done
          done

  build_esp32c3_v4_x:
    runs-on: ubuntu-latest
    needs: pre_build
    if: ${{ needs.pre_build.outputs.should_skip != 'true' }}
    strategy:
      fail-fast: false
      matrix:
        build_method:
          - idf
        branch:
          # esp32c3 support was introduced in v4.3.
          - master
          - v4.3.4
          - v4.4.2
        target:
          - esp32c3
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          sudo apt-get install \
            bison \
            ccache \
            flex \
            gcc \
            git \
            gperf \
            libffi-dev \
            libncurses-dev \
            libssl-dev \
            make \
            wget

      - name: Set environment variables
        id: set_env
        run: |
          TOOLCHAIN_DIR="${HOME}/.espressif/tools"
          REPO_DIR=`pwd`
          EXAMPLE_DIR="${REPO_DIR}/examples"
          __PROJECT_PATH=`pwd`
          IDF_PATH="${__PROJECT_PATH}/idf"

          # cache-idf-tools needs __PROJECT_TOOLCHAIN_DIR
          echo "PROJECT_TOOLCHAIN_DIR=${TOOLCHAIN_DIR}" >> $GITHUB_OUTPUT

          echo "IDF_PATH=${IDF_PATH}" >> ${GITHUB_ENV}
          echo "IDF_TARGET=${{ matrix.target }}" >> ${GITHUB_ENV}
          echo "__PROJECT_EXAMPLE_DIR=${EXAMPLE_DIR}" >> ${GITHUB_ENV}

      - name: Checkout the SDK
        uses: actions/checkout@v3
        with:
          repository: espressif/esp-idf
          path: idf
          submodules: recursive
          ref: ${{ matrix.branch }}

      - name: Cache esp-idf tools

        # cache esp-idf tools. each tagged branch has fixed versions of tools.
        # the versions do not change. the master is an exception as it is a
        # moving target. do NOT cache tools if the branch is master.
        uses: actions/cache@v3
        id: cache-tools
        if: ${{ matrix.branch != 'master' }}
        with:
          path: ${{ steps.set_env.outputs.PROJECT_TOOLCHAIN_DIR }}
          key: ${{ runner.os }}-${{ matrix.branch }}-${{ matrix.target }}-cache-tools-1

      - name: Run install.sh
        if: ${{ steps.cache-tools.outputs.cache-hit != 'true' || matrix.branch == 'master' }}
        run: |
          ${IDF_PATH}/install.sh

      - name: Run idf_tools.py install-python-env
        run: |
          ${IDF_PATH}/tools/idf_tools.py install-python-env

      - name: Build (idf.py)
        if: ${{ matrix.build_method == 'idf' }}
        run: |
          components_to_build="${{ needs.pre_build.outputs.components_to_build }}"

          echo "The component whose examples need to be built:"
          echo "${components_to_build}"

          # find out drivers that do not support the target
          EXCLUDE_COMPONENTS=""
          ALL_COMPONENTS=`ls -1 components`
          for C in ${ALL_COMPONENTS}; do
            echo "see if component ${C} supports the target ${IDF_TARGET}"
            if [ ! -f "components/${C}/.eil.yml" ]; then
              echo "metadata file for component ${C}, components/${C}/.eil.yml, does not exist"
              exit 1
            fi
            if yq '.components[].targets[].name' "components/${C}/.eil.yml" | grep -q ${IDF_TARGET}; then
              echo "component ${C} supports ${IDF_TARGET}"
            else
              echo "component ${C} does not support ${IDF_TARGET}. adding it to EXCLUDE_COMPONENTS"
              EXCLUDE_COMPONENTS="${EXCLUDE_COMPONENTS} ${C}"
            fi
          done
          echo "EXCLUDE_COMPONENTS=${EXCLUDE_COMPONENTS}"
          export EXCLUDE_COMPONENTS

          # remove components in EXCLUDE_COMPONENTS from components_to_build
          for ec in ${EXCLUDE_COMPONENTS}; do
            components_to_build=`echo ${components_to_build} | tr ' ' '\n' | grep -v ${ec} | tr '\n' ' '`
          done

          . ${IDF_PATH}/export.sh

          # XXX share cache between examples.
          # see "Compiling In Different Directories" in ccache(1)
          # |                                        |  4.0.1  | master  |
          # |----------------------------------------|---------|---------|
          # | without ccache                         | 33m 42s | 50m 27s |
          # | CCACHE_BASEDIR and CCACHE_NOHASHDIR    | 10m 41s | 16m 38s |
          export CCACHE_BASEDIR="${__PROJECT_EXAMPLE_DIR}"
          export CCACHE_NOHASHDIR=true

          echo "final components_to_build:"
          echo "${components_to_build}"
          for component_to_build in ${components_to_build}; do
            cd ${GITHUB_WORKSPACE}
            echo "Building examples for ${component_to_build} under directory ${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}"
            for i in $(ls -d *); do
              cd "${__PROJECT_EXAMPLE_DIR}/${component_to_build}/${i}"
              echo "Building example ${i} for component ${component_to_build} in directory ${PWD}..."
              idf.py --ccache build
            done
          done
  all_build:
    # a meta job that requires all of the above so that repository
    # admin can choose a single test name in "Require status checks to pass
    # before merging". A trick obtained from:
    #
    # https://github.com/jazzband/pip-tools/issues/1085#issuecomment-619172509
    name: All build
    runs-on: ubuntu-latest
    needs:
      - build_esp32_master
      - build_esp32_v4_x
      - build_esp8266
      - build_esp8266_v3_3_x
      - build_esp32s2_v4_x
      - build_esp32c3_v4_x
    steps:
      - name:
        run: |
          echo "All builds finished"
